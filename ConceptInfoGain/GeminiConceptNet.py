# Logging setup
import logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
# -------------------------------
# New Prompt Definitions and Setup
# -------------------------------

# Existing prompts for Guesser and Oracle (if desired, you can keep the existing ones for other flows)
ynpg = "You are named Guesser. You are trying to guess what physical object Oracle is thinking of by asking clarifying questions and making explicit guesses."
ynpo = "You are named Oracle. Guesser will ask questions and make guesses about the physical object you are thinking of. Answer in complete, natural language sentences."

# New Candidate Generator prompt with few-shot examples.
# candidatePrompt = (
#     'You are a Candidate Generator for a 20 Questions game. Your task is to analyze the provided conversation history and generate a list of EXACTLY 20 candidate physical objects (concrete nouns) that could be the answer. Your output must be a comma-separated list of 20 distinct items, with no additional text, explanation, punctuation (except commas), or commentary. '
#     'If the conversation history does not provide enough clues, default to common objects. For example, if clues hint at something metallic, sharp, and portable, your output could be:'
#     '"key, knife, sword, fork, axe, shovel, pliers, wrench, saw, scissors, hammer, drill, needle, pin, blade, clip, clamp, screwdriver, chisel, file"'
#     'IMPORTANT: Only output exactly 20 items separated by commas. Do not include any questions, statements, or additional words.'
#     'Conversation History:'
# )


# Guesser prompt.
opg = (
    "You are named Guesser. Your objective is to narrow down which physical object Oracle is thinking of by both asking clarifying yes/no questions and making explicit guesses when you are confident. "
    "At each turn, you will receive an aggregated list of candidate attributes generated by an external Candidate Generator. These attributes represent common features across possible objects derived from the conversation clues. "
    "For example, if the candidate attributes include 'metal, sharp, portable', you might ask: 'Does it have a metallic body used for cutting?' or explicitly guess: 'Is it a knife?'. "
    "Use these candidate attributes to inform your next move. Your response should be in natural language and must begin with 'Guesser said:' followed by your clarifying question or explicit guess."
)

# Oracle prompt.
opo = (
    "You are named Oracle. Your role is to answer the questions and guesses posed by Guesser in natural, complete sentences. "
    "When Guesser asks a yes/no question, respond with a natural language answer such as 'No, it is not a key.' or 'Yes, it is used for ...'. "
    "If Guesser makes an explicit guess that is correct, reply with 'Correct!' (optionally with a brief comment), otherwise provide a natural explanation of why the guess is incorrect. "
    "Do not ask any questions or offer unsolicited information. Your response must begin with 'Oracle said:' followed by your answer."
)

# -------------------------------
# Existing Helper Functions
# -------------------------------

def clean_candidate(candidate: str) -> str:
    """
    Cleans the candidate string to extract a valid physical object name by removing extraneous leading words and punctuation.
    This function:
      1. Strips whitespace and surrounding quotes/punctuation.
      2. If a colon is present, keeps only the text after the colon.
      3. Removes extraneous leading words (e.g., 'okay', 'ok', 'since', 'it's likely', 'um', 'uh', 'hmm', 'well').
      4. Removes leading articles such as 'a' or 'an'.
      5. Performs final cleanup of any residual punctuation.
    """
    import re
    candidate = candidate.strip().strip('\"\'“”‘’')
    if ':' in candidate:
        candidate = candidate.split(':', 1)[1].strip()
    # Remove extraneous leading words and punctuation.
    pattern = r'^(okay|ok|since|it\'?s likely|um|uh|hmm|well)[\s,\-.:;]+'
    candidate = re.sub(pattern, '', candidate, flags=re.IGNORECASE)
    # Remove leading articles.
    candidate = re.sub(r'^(a|an)\s+', '', candidate, flags=re.IGNORECASE)
    candidate = candidate.strip().strip('.,;:!?\'\"')
    return candidate

import random
from query_gpt import ChatBot
from query_gpt import MultiChatBot
from huggingface_hub import login
import transformers
import torch
ALLOWED_RELATIONS = ['UsedFor', 'HasProperty', 'AtLocation', 'IsA']

PROVIDER = 'gemini'
MODEL = 'gemini-2.0-flash-lite'


# -------------------------------
# Shared requests session with retry/backoff for ConceptNet API
# -------------------------------
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# Configure a shared session with retry/backoff
session = requests.Session()
retry = Retry(
    total=3,
    backoff_factor=1,
    status_forcelist=[429, 500, 502, 503, 504],
    allowed_methods=["GET"]
)
session.mount("https://", HTTPAdapter(max_retries=retry))

# -------------------------------
# ConceptNet semantic mapping setup
# -------------------------------
import pandas as pd


def queryConceptNet(candidate, allowed_rels={"MadeOf", "UsedFor", "HasProperty"}):
    base_url = "https://api.conceptnet.io/c/en/"
    candidate_url = base_url + candidate.lower()
    try:
        resp = session.get(candidate_url, timeout=5)
        data = resp.json()
    except Exception as e:
        logger.error("Failed ConceptNet query for %s: %s", candidate, e)
        return ""
    attributes = []
    for edge in data.get("edges", []):
        rel = edge.get("rel", {}).get("label", "")
        if rel in allowed_rels:
            end_label = edge.get("end", {}).get("label", "")
            if end_label and end_label.lower() != candidate.lower():
                attributes.append(end_label.lower())
    unique_attrs = list(set(attributes))
    return ", ".join(unique_attrs)

from collections import Counter
import math

def aggregateAttributes(candidates, allowed_rels={"MadeOf", "UsedFor", "HasProperty"}, k=None, use_entropy=False):
    counter = Counter()
    for candidate in candidates:
        cleaned_candidate = clean_candidate(candidate)
        if not cleaned_candidate:
            continue
        attrs = queryConceptNet(cleaned_candidate, allowed_rels=allowed_rels)
        attrs_list = [x.strip() for x in attrs.split(",") if x.strip()]
        counter.update(attrs_list)

    total = sum(counter.values())
    if total == 0:
        return ""

    if use_entropy:
        best_attr = None
        best_entropy = -1.0
        for attr, cnt in counter.items():
            p = cnt / total
            # binary entropy for split on attr: IG = - [p log2 p + (1-p) log2(1-p)]
            # handle edge cases
            h = 0.0
            if p > 0:
                h -= p * math.log2(p)
            if p < 1:
                h -= (1-p) * math.log2(1-p)
            if h > best_entropy:
                best_entropy = h
                best_attr = attr
        return best_attr or ""

    # fallback to frequency-based top-k
    if k:
        attrs_list = [attr for attr, _ in counter.most_common(k)]
    return ", ".join(attrs_list)

# -------------------------------
# Refactored Enriched Input in Augmented Guessing Game
# -------------------------------
def augmentedGuessingGame(objectList, res, promptG, promptO, promptC, relation_type_rotation=False, rel_list = ["UsedFor","HasProperty","AtLocation","IsA"], n=20, k=5):
    """
    Plays the 20 Questions game with an augmented step using an external Candidate Generator.
    At each turn:
      - The Candidate Generator (a third LLM instance) generates 20 candidate physical objects from the conversation history.
      - Their attributes are aggregated via ConceptNet.
      - The aggregated candidate attributes are provided to the Guesser to inform the next clarifying question or guess.
    """
    objects = open(objectList, 'r', encoding='utf8').read().split("\n")
    
    # Initialize Candidate Generator instance
    candidatePrompt = (
        f'You are a Candidate Generator for a 20 Questions game. Your task is to analyze the provided conversation history and generate a list of EXACTLY {n} candidate physical objects (concrete nouns) that could be the answer. Your output must be a comma-separated list of {n} distinct items, with no additional text, explanation, punctuation (except commas), or commentary. '
        'If the conversation history does not provide enough clues, default to common objects. For example, if clues hint at something metallic, sharp, and portable, your output could be:'
        '"key, knife, sword, fork, axe, shovel, pliers, wrench, saw, scissors, hammer, drill, needle, pin, blade, clip, clamp, screwdriver, chisel, file"'
        f'IMPORTANT: Only output exactly {n} items separated by commas. Do not include any questions, statements, or additional words.'
        'Conversation History:'
    )
    candidateGen = ChatBot(candidatePrompt, model=MODEL, provider=PROVIDER)

    rel_counter = 0
    
    for i in range(len(objects)):
        guesser = MultiChatBot(promptG, model=MODEL, provider=PROVIDER)
        oracle = ChatBot(promptO + objects[i] + ".", model=MODEL, provider=PROVIDER)
        if len(promptC) == 2:
            checker = ChatBot(promptC[0], model=MODEL, provider=PROVIDER)
        responseO = "Oracle said: What is your first question?"
        responseHistory = [responseO]
        inputHistory = []
    
        while ((("Incorrect" in responseO or "not correct" in responseO or "not Correct" in responseO or "Correct" not in responseO)
               and len(responseHistory) < 100)):
            # Build a prompt for the Candidate Generator using the conversation history
            candidate_history = "\n".join(responseHistory)
            candidateGenPrompt = candidatePrompt + "\nConversation History:\n" + candidate_history
            # Generate candidate objects using the Candidate Generator, with exception logging
            try:
                candidates_response = candidateGen(candidateGenPrompt)
            except Exception as e:
                logger.warning("Candidate Generator error: %s", e)
                candidates_response = ""
            # Split the candidate response into a list, ensuring proper cleanup
            candidates = [item.strip() for item in candidates_response.split(",") if item.strip()]

            # Retrieve and aggregate attributes from ConceptNet for these candidates
            if relation_type_rotation:
                rel_counter += 1
                aggregated_attributes = aggregateAttributes(candidates, allowed_rels={rel_list[rel_counter % len(rel_list)]}, k=k)
            else:
                aggregated_attributes = aggregateAttributes(candidates, k=k)
            
            if not aggregated_attributes:
                aggregated_attributes = "no external candidate clues available"
    
            # Compose enriched input for the Guesser with explicit instructions and few-shot examples
            if relation_type_rotation:
                enriched_input = (
                    f"Aggregated candidate {rel_list[rel_counter % len(rel_list)]} attributes from external analysis: " + aggregated_attributes + ".\n" +
                    "Conversation History:\n" + "\n".join(responseHistory) + "\n" +
                    "Based on these clues, please generate your next clarifying yes/no question or explicit guess. For example, if these attributes include 'metal, sharp, portable', you might ask: 'What material is it made of?' or guess: 'Is it a knife?'."
                )
            else:
                enriched_input = (
                    "Aggregated candidate attributes from external analysis: " + aggregated_attributes + ".\n" +
                    "Conversation History:\n" + "\n".join(responseHistory) + "\n" +
                    "Based on these clues, please generate your next clarifying question or explicit guess. For example, if these attributes include 'metal, sharp, portable', you might ask: 'What material is it made of?' or guess: 'Is it a knife?'."
                )
            inputHistory.append("Aggregated attributes: " + aggregated_attributes)
    
            if len(promptC) == 2:
                try:
                    responseG = guesser(enriched_input + promptC[1])
                except Exception as e:
                    logger.error("Guesser error: %s", e)
                    responseG = ""
                while ('0' in checker(responseG)):
                    try:
                        responseG = guesser.invalidQuestion(promptC[1])
                    except Exception as e:
                        logger.error("Guesser error: %s", e)
                        responseG = ""
            else:
                try:
                    responseG = guesser(enriched_input)
                except Exception as e:
                    logger.error("Guesser error: %s", e)
                    responseG = ""
    
            responseHistory.append(responseG)
            inputHistory.append(responseG)
            # Build Oracle input with explicit target reminder and instruction
            defense_prompt = (
                f"{promptO} The secret object is '{objects[i]}'. "
                "Answer honestly using only yes/no or 'Correct!' with minimal explanation.\n"
                f"Question: {responseG}"
            )
            try:
                responseO = oracle(defense_prompt)
            except Exception as e:
                logger.error("Oracle error: %s", e)
                responseO = "Oracle said: "
            if (( "Incorrect" in responseO or "not correct" in responseO or "not Correct" in responseO or "Correct" not in responseO)
                and (" " + objects[i]) in responseG):
                responseO = "Correct."
            responseHistory.append(responseO)
    
        print(objects[i] + "," + str(int((len(responseHistory)-1)/2)) + "," + "\t".join(responseHistory) + "\n")
        open(res, "a", encoding='utf8').write(
            objects[i] + "," + str(int((len(responseHistory)-1)/2)) + "," + "\t".join(responseHistory) + "\n"
        )
        open("input" + res, "a", encoding='utf8').write(
            objects[i] + "," + str(int((len(inputHistory)-1)/2)) + "," + "\t".join(inputHistory) + "\n"
        )

# Example call (uncomment the appropriate line to run this version)
# for n,k in [(5,5),(10,5),(20,5),(50,5),(100,5), (5,1),(10,1),(20,1),(50,1),(100,1), (5,None),(10,None),(20,None),(50,None),(100,None)]:
for n,k in [(100,1), (5,None),(10,None),(20,None),(50,None),(100,None)]:
    augmentedGuessingGame("objectsSimple.txt", f"Gemini_ConceptNet_n{n}_k{k}_simple.txt", opg, opo, [0], relation_type_rotation=False, n=n, k=k)
    augmentedGuessingGame("objectsComplex.txt", f"Gemini_ConceptNet_n{n}_k{k}_complex.txt", opg, opo, [0], relation_type_rotation=False, n=n, k=k)
