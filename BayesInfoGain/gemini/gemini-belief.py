from geminiChat import ChatBot, MultiChatBot
from huggingface_hub import login
import transformers

from env import MODEL, PROVIDER
from Helpers import Logger, Loader

from typing import List, Dict, Tuple
import math


ResponseHistoryLimit = 30

object_path = "objects20SC.txt"
logger = Logger(filename="gemini/SCAnything-4.txt", separater=", ")
debug_logger = Logger(filename="gemini/debug-SCAnything-4.txt")

def initGuesserPrompt():
    return '''You are named the Guesser. Your task is to guess which physical object the Oracle is thinking of by both asking open ended questions about the object and making explicit guesses when you are confident. At each turn, you will receive the current beliefs about the object generated by an external Belief Generator. The beliefs represent a concept and its confidence score. Use these beliefs to inform your next question. For example, if the current beliefs include 'metal: 0.8, sharp: 1, portable: 0.7', you might ask: 'Does it have a metallic body used for cutting?' or explicitly guess: 'Is it a knife?'. You will not get the beliefs about the object in the first turn.
Rules:
1. Use the Current Beliefs about the object to inform your next questions
2. Output exactly ONE question sentence that ends with '?' at each turn.
3. You can make a guess for the object by asking a "Is it a ..." question.
4. You cannot directly ask the Oracle what Object it is thinking about unless you are making a guess.
5. Do NOT answer your own question.
6. Always ask a question and do not repeat a question you have already asked'''

def initGuesserPromptV2():
    return '''You are named Guesser. You are trying to guess what physical object or physical material Oracle is thinking of. You will open ended questions to get more information about the object. When you believe you have enough information about the object you will guess what it is. Your guessing will be informed by your prior guesses. Do not explain your reasoning in your guess, only say your question. You will start each message with Guesser said: . If you guess wrong you will ask more questions about the object until you have enough information to guess again. At each turn, you will receive the current beliefs about the object generated by an external Belief Generator. The beliefs represent a concept and its confidence score. Use these beliefs to inform your next question. For example, if the current beliefs include 'metal: 0.8, sharp: 1, portable: 0.7', you might ask: 'Does it have a metallic body used for cutting?' or explicitly guess: 'Is it a knife?'. You will not get the beliefs about the object in the first turn. Try to get as much information about the object before making guesses. '''

def initOraclePrompt(hidden_object):
    # 2. Use one short sentence; no extra trivia.
    # 3. Do not ask questions and never make a guess.
    return f'''You are named the Oracle. Your task is to answer the questions and guesses posed about the object by the Guesser in natural complete sentences. When Guesser asks a yes/no question, respond with a natural language answer such as 'No, it is not a key.' or 'Yes, it is used for ...'. The object is: {hidden_object}.
Rules:
1. Only answer the Guesser's last question in exactly one concise sentence.
2. Refer to the object as "The object" or "It"
3. Do not give information about the object that the Guesser has not asked for.
4. Do not ask any questions, offer explanations or make guesses.
5. If the user's question *is* a correct full guess of the object
   (or an “Is it a …?” that matches the object), only reply with: "Correct".
6. Stop after answering the question asked by the Guesser.
7. Your response must begin with 'Oracle said:' followed by your answer.
'''

def initInterpreterPrompt():
    return f'''You are named the Interpreter. Your task is to generate a comma-separated relevance-scored list of candidate concepts based on the Guesser's questions and the Oracle's answers to that question. Candidate concepts are inferences you can make about the physical or functional attributes or location or category of the object that the Oracle is answering about.
Rules
1. Every concept and its corresponding score must be separated by a colon and each concept-score pair must followed by a comma
2. Each score is a float in (-1, 1). 1 = strongly positive correlation, -1 = strongly negative correlation.
3. Do not output any additional text, explanation, punctuation (except commas), or commentary, metadata tags, special tokens, statements, explanations, additional works, questions or guesses
'''

def getConversationforInterpreter(question, response):
    return f'''Conversation History:
Guesser asked: {question}
{response}'''

def readBeliefResponse(response):
    concept_scores = {}
    total = 0
    for line in response.strip().split(","):
        if ":" in line:
            concept, score = line.split(":")
            try:
                s = float(score.strip())
                c = concept.strip()
                if s < 0:
                    c = "Not " + c
                    s *= -1
                concept_scores[c] = s
                total = total + concept_scores[c]
            except ValueError:
                continue
    return {k: v / total for k, v in concept_scores.items()}

def updateBelief(prior: Dict[str, float], response: str, threshold: float = 0.5,
                  alpha: float = 1, eps=1e-12) -> Dict[str, float]:
    concept_scores = readBeliefResponse(response)
    posterior = prior.copy()
    for concept, score in concept_scores.items():
        if concept in posterior:                     # naive mapping
            posterior[concept] *= math.exp(alpha * score)
        else:
            posterior[concept] = math.exp(alpha * score)
        if posterior[concept] <= threshold:
            if concept in posterior: posterior.pop(concept)
    for k in posterior:
        posterior[k] = max(posterior[k], eps)
    # renormalise
    z = max(sum(posterior.values()), eps)
    for k in posterior:
        posterior[k] /= z
    return posterior

def updateBeliefV2(prior: Dict[str, float], response: str, threshold: float = 0.5,
                  alpha: float = 1, eps=1e-12) -> Dict[str, float]:
    concept_scores = readBeliefResponse(response)
    posterior = prior.copy()
    for concept, score in concept_scores.items():
        if concept in posterior:                     # naive mapping
            posterior[concept] *= (1 + alpha * score)
        else:
            posterior[concept] = (alpha * score)
        if posterior[concept] <= threshold:
            if concept in posterior: posterior.pop(concept)
    for k in posterior:
        posterior[k] = max(posterior[k], eps)
    # renormalise
    z = max(sum(posterior.values()), eps)
    for k in posterior:
        posterior[k] /= z
    return posterior

def formatPriorBeliefs(prior, threshold=0.0):
    sorted_items = sorted(prior.items(), key=lambda x: -x[1])
    described = [f"{k} ({p:.2f})" for k, p in sorted_items if p > threshold]
    if len(described) == 0:
        return ""
    else:
        return "Current belief about the object is that it is: " + ", ".join(described)

def guessingGame(object_path, logger, debug_logger):

    objects = open(object_path, 'r', encoding='utf8').read().split("\n")
    for i in range(len(objects)):
        round_num = 1

        systemPromptG = initGuesserPromptV2()
        guesser = MultiChatBot(model=MODEL, provider=PROVIDER, generation_config={ 'system_instruction': systemPromptG })
        responseO = "Oracle said: What is your first question?"
        systemPromptO = initOraclePrompt(objects[i])
        oracle = ChatBot(model=MODEL, provider=PROVIDER, generation_config={ 'system_instruction': systemPromptO })
        systemPromptI = initInterpreterPrompt()
        interpreter = ChatBot(model=MODEL, provider=PROVIDER, generation_config={ 'system_instruction': systemPromptI })
        prior = {}
        context = responseO
        while ((("Incorrect" in responseO or "not correct" in responseO or "not Correct" in responseO or "Correct" not in responseO)
               and round_num < ResponseHistoryLimit)):
            logger.log(f"\n --- Round {round_num} --- \n")
            
            current_belief = formatPriorBeliefs(prior)
            guesserMessage = responseO+current_belief+("Oracle said: What is your next question?" if round_num>1 else "")
            question = guesser(message=guesserMessage)
            context += f"{question}"
            logger.log(f"{question}")

            response = oracle(question)
            context += f"{response}"
            logger.log(f"{response}")

            promptI = getConversationforInterpreter(question, response)
            responseC = interpreter(promptI)
            logger.log(f"{responseC}")
            prior = updateBelief(prior, responseC)
            for (c, p) in sorted(prior.items(), key=lambda x: -x[1])[0:10]:
                debug_logger.log(f"  {c}: {p:.3f}")

            round_num += 1
        debug_logger.log(f"{context}")


guessingGame(object_path, logger=logger, debug_logger=debug_logger)